[{"title":"tp5使用PHPexcel导出文件","date":"2017-01-04T01:37:46.000Z","path":"2017/01/04/tp5使用PHPexcel导出文件/","text":"一、使用composer安装phpexcel第一种方式：在项目根目录下的composer.json里面添加phpexcel123&quot;require&quot;: &#123; &quot;phpoffice/phpexcel&quot;: &quot;1.8.*&quot; &#125; 进入composer ,cd到根目录 执行 composer install第二种方式: 直接运行命令php composer.phar require phpoffice/phpexcel 二、封装导出方法private function getExcel($fileName,$headArr,$data){ //对数据进行检验 if(empty($data) || !is_array($data)){ die(&quot;data must be a array&quot;); } //检查文件名 if(empty($fileName)){ exit; } $date = date(&quot;Y_m_d&quot;,time()); $fileName .= &quot;_{$date}.xls&quot;; //创建PHPExcel对象，注意，不能少了\\ $objPHPExcel = new \\PHPExcel(); $objProps = $objPHPExcel-&gt;getProperties(); //设置表头 $key = ord(&quot;A&quot;); foreach($headArr as $v){ $colum = chr($key); $objPHPExcel-&gt;setActiveSheetIndex(0) -&gt;setCellValue($colum.&apos;1&apos;, $v); $key += 1; } $column = 2; $objActSheet = $objPHPExcel-&gt;getActiveSheet(); foreach($data as $key =&gt; $rows){ //行写入 $span = ord(&quot;A&quot;); foreach($rows as $keyName=&gt;$value){// 列写入 $j = chr($span); $objActSheet-&gt;setCellValue($j.$column, $value); $span++; } $column++; } $fileName = iconv(&quot;utf-8&quot;, &quot;gb2312&quot;, $fileName); //重命名表 // $objPHPExcel-&gt;getActiveSheet()-&gt;setTitle(&apos;test&apos;); //设置活动单指数到第一个表,所以Excel打开这是第一个表 $objPHPExcel-&gt;setActiveSheetIndex(0); header(&apos;Content-Type: application/vnd.ms-excel&apos;); header(&quot;Content-Disposition: attachment;filename=\\&quot;$fileName\\&quot;&quot;); header(&apos;Cache-Control: max-age=0&apos;); $objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, &apos;Excel5&apos;); $objWriter-&gt;save(&apos;php://output&apos;); //文件通过浏览器下载 exit; } 然后调用刚刚封装的方法 public function out(){ //要导出的数据放在一个数组里 $data=array( array(&apos;username&apos;=&gt;&apos;zhangsan&apos;,&apos;password&apos;=&gt;&quot;123456&quot;), array(&apos;username&apos;=&gt;&apos;lisi&apos;,&apos;password&apos;=&gt;&quot;abcdefg&quot;), array(&apos;username&apos;=&gt;&apos;wangwu&apos;,&apos;password&apos;=&gt;&quot;111111&quot;), ); //导出的文件名 $filename=&quot;test_excel&quot;; //每一列的标题 $headArr=array(&quot;用户名&quot;,&quot;密码&quot;); $this-&gt;getExcel($filename,$headArr,$data); } 后面我们直接调用控制器里的 out方法就可以了！","tags":[]},{"title":"'常用的设计模式之单例模式'","date":"2016-12-29T02:54:39.000Z","path":"2016/12/29/常用的设计模式之单例模式/","text":"单例模式就是只能让我们实例化一次和创建一个对象的类。像文件类，session类等只需要实例化一次就可以在全局中应用。 1、 非单例模式的普通类，会出现的问题。1234567891011121314151617181920212223&lt;?phpclass Db&#123; private $instance=null; public function __construct($config=[]) &#123; $dsn = sprintf('mysql:host=%s;dbname=%s', $config['db_host'], $config['db_name']); $this-&gt;db = new PDO($dsn, $config['db_user'], $config['db_pass']); &#125;&#125;$config = array( 'db_name' =&gt; 'phpcmsv9', 'db_host' =&gt; 'localhost', 'db_user' =&gt; 'root', 'db_pass' =&gt; 'root');$ob=new Db($config);var_dump($ob);$ob2=new Db($config);var_dump($ob2);$ob3=new Db($config);var_dump($ob3);?&gt; 上面会输出的内容为：(1) &#123;1234567891011121314 [&quot;db&quot;:&quot;Db&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125;object(Db)#3 (1) &#123; [&quot;db&quot;:&quot;Db&quot;:private]=&gt; object(PDO)#4 (0) &#123; &#125;&#125;object(Db)#5 (1) &#123; [&quot;db&quot;:&quot;Db&quot;:private]=&gt; object(PDO)#6 (0) &#123; &#125;&#125; 每个对象都会占用一个资源，如果实例100次就会占用100次，非常消耗服务器内存和资源。 2、 单例模式例子12345678910111213141516171819202122232425262728293031&lt;?phpclass Test&#123; private static $instance=null; private $db=null; private function __construct($config=array()) &#123; $dsn = sprintf('mysql:host=%s;dbname=%s', $config['db_host'], $config['db_name']); $this-&gt;db = new PDO($dsn, $config['db_user'], $config['db_pass']); &#125; public static function getInstance($config=array()) &#123; if(self::$instance == null) &#123; self::$instance= new self($config); &#125; return self::$instance; &#125;&#125;$config = array( 'db_name' =&gt; 'phpcmsv9', 'db_host' =&gt; 'localhost', 'db_user' =&gt; 'root', 'db_pass' =&gt; 'root');$obj=Test::getInstance($config);var_dump($obj);$obj1=Test::getInstance($config);var_dump($obj1);$obj2=Test::getInstance($config);var_dump($obj2);?&gt; 上面的输出内容为：123456789101112131415object(Test)#1 (1) &#123; [&quot;db&quot;:&quot;Test&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125;object(Test)#1 (1) &#123; [&quot;db&quot;:&quot;Test&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125;object(Test)#1 (1) &#123; [&quot;db&quot;:&quot;Test&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125; 我们可以看出用单例模式，每次调用都是返回的同一个对象，获得的对象ID是一样的。我们控制住基类，在源头上限制这个类，使它无法生成多个对象，直接返回。 3、总结 单例模式了违法单一职责原则，因为它自己控制了自己的实例化和生命周期。 单例模式对应用表现为全局状态。全局状态被视为是不良设计，因为所有代码都可以修改它的值。在调试的时候，很难弄清楚全局变量的当前状态是哪一段代码造成的。 在单元测试的时候，单例模式难以测试。如果不进行单元测试，又会影响系统的质量。 单例模式在应用请求的整个生命周期中都有效，这点类似全局变量，会降低程序的可测试性。大部分情况下，也可以用依赖注入来代替单例模式，避免在应用中引入不必要的耦合。 所以，对于仅需生成一个对象的类，首先考虑用依赖注入方式，其次考虑用单例模式来实现。","tags":[]},{"title":"hexo 和github搭建个人博客","date":"2016-12-26T08:27:37.673Z","path":"2016/12/26/hexo 和github搭建个人博客/","text":"一、需要安装的软件1、安装git ubuntu上安装git ： sudo apt-get install git windows直接下载git安装包2、安装nodejs ubuntu 上安装node apt install nodejsapt all npm Windows到nodejs官网下载最新版安装包。 二、正式安装hexo 进入你的文件目录 执行以下命令 sudo npm install -g hexo 软件安装完成后初始化它 hexo init 执行成功后就本地就安装完成了，当前目录就是博客的根目录。 生成静态页面 hexo generate 或者 hexo g 本地启动预览 hexo server 或者 hexo s 后面可以加上 --debug 参数查看运行状态，浏览器输入http://localhost:4000 查看本地预览，如果网站打开了说明配置OK。三、配置github 进入你的github，新建一个仓库名字为：名字+github.io 打开你的博客根目录下的 vim _config.yml文件的最后几行，修改 ` 然后执行命令 hexo g hexo d,第一条是重新生成静态页面，第二天是部署到github，执行成功后静态页面就提交到你的github仓库里了。 最后访问你的github地址 xxx.github.io就可以看到效果了。四、绑定域名到github 到你的域名解析后台解析或者修改一个新的域名地址，记录类型为CNAME，记录值为你的github仓库地址：xxx.github.io 如下图所示： 然后在你的博客目录 -&gt;source目录下面新建一个CNAME的文件，内容为你刚刚解析的域名地址。（所以需要提交到github的文件都是放在source这个目录里面的） 再次执行 hexo g和 hexo d就可以了五、hexo常用命令 hexo new &#39;filename 创建新文章 hexo clean 清除缓存 hexo new page &#39;filename&#39; 创建新页面 hexo g 生成页面 hexo d部署项目( 生成并部署可以用hexo d -g ) hexo s 开启预览访问后记 如果你想建设一个写文章的bolg的话，用hexo和github真的是一个不错的选择，没有自己搭建服务器的烦恼。可以把维护网站的时间用来多思考，总结，和分享。又比在其他第三方平台上多了一些个性化的功能。反正我觉得挺棒的。","tags":[]}]