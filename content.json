[{"title":"迟来的的2016年终总结","date":"2017-01-04T03:12:37.000Z","path":"2017/01/04/迟来的的2016年终总结/","text":"今年的年终总结本来会迟到的，前两天电脑坏了，还好今天修好了。刚刚看了时间的朋友跨年演讲，里面说到我们在消费时不光要考虑金钱成本，更重要的是时间成本。回顾2016的点滴，喜忧参半，没有什么特别突出的地方。翻出2015年的年终总结，对照当时给自己制定的目标，大部分还是完成了，有一些还在进行中。有几个还没完成的，没有完成的慢慢的就被淘汰了，应该不是自己真正想要的东西，可能是所谓的伪目标吧。 去年告诉自己会跳一次槽，工资涨一点，今年反而跳了两次，年初一次，年尾一次，薪水也超出了自己的预期。还有每个月看一本书，每周看一部电影。由于现在是一名程序员，看技术方面的书籍要多一点，大概看了有四五本的样子。电影从国庆过后就看得比较少了，上半年基本还能保持。而且对美剧产生了兴趣，看了有两三部的样子。专业技能在利用业余时间多多少少有进步了一点，学会了git和svn，并试着用它们管理代码，到后面习惯掌握它们。liunx系统的继续学习，个人搭建公司服务器，使用的centos，自己电脑安装ubuntu使用，基本能达到熟练的效果。在上一个公司对微信开发这一块用得比较多，可以说扩宽了自己的知识面和短板吧。后面自己又和朋友合伙购买了vps，一方面用来科学上网，另一方面当作一个测试服务器。总体来说，2016年自己在工作上有进步，但不是特别大，有一点令自己满意的就是，大的方向是有了，不再像以前那么迷茫了。因为，没有方向，光走是没有意义的。在接下来的2017年需要好好管理自己的时间，技术上的深度和广度都还不够，感觉自己离专业两个字还有很大的差距。应该在数据库、PHP高级技术、linux、JavaScript和css这几方面提升一下。首先得认认真真的把之前买的《JavaScript权威指南》看一篇吧。然后继续坚持写技术博客，坚持阅读，养成一个良好的阅读习惯和保持一个阅读量，先计划一个月一本书吧。希望在写2017年的年终总结的时候能列出这12本书的书单并全部阅读过。 经过一年多的努力，最值得高兴的是各种款也差不多要还完了，预料之中的话下个月的完了。而且从2017起开始记账了，继续使用了以前没坚持下来的随手记。因为现在还是在财富积累的初期阶段，要懂得开源节流。虽然谈不上理财，但是一方面可以养成一个花钱用钱的好习惯，另一方面可以总结出每个月的钱花在哪，有些东西买了到底是不是自己真正想要的。这样坚持记一年，希望在下一次的年终总结中可以晒出一年的账单。 生活方面，这一年回家的次数变多了，这么几年了，今年应该是陪伴家人时间最多的一年吧。情侣之间虽然偶尔也有争吵，有时也会冷战和赌气。但放眼望去，一起走过来的这两三百天时间。其实大家都进步了，可能不够想象中的完美。每次看到她都感觉变成熟了进步了，其实我真的很 开心。至于爱不爱，其实真的没怀疑过。希望自己在2017能改掉一些固执的牛脾气。多用有温度的话语去感染别人。哪怕自己是对的。感情和家庭像工作一样需要用心去经营。 嗯！就这么多，提高自己的专业技术能力，养成阅读的习惯，坚持写博客，坚持记账，多陪伴家人，脾气好一点，用心去热爱生活，虽然生活是那么现实。多挣钱，让自己变得更好，把账单、书单、爱情都晒在2017的总结里。 2016年12月31日","tags":[]},{"title":"tp5使用PHPexcel导出文件","date":"2017-01-04T01:37:46.000Z","path":"2017/01/04/tp5使用PHPexcel导出文件/","text":"tp5使用PHPexcel导出文件一、使用composer安装phpexcel第一种方式：在项目根目录下的composer.json里面添加phpexcel123\"require\": &#123; \"phpoffice/phpexcel\": \"1.8.*\" &#125; 进入composer ,cd到根目录 执行 composer install第二种方式: 直接运行命令php composer.phar require phpoffice/phpexcel 二、封装导出方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getExcel($fileName, $headArr, $data)&#123; //对数据进行检验 if (empty($data) || !is_array($data)) &#123; die(\"data must be a array\"); &#125; //检查文件名 if (empty($fileName)) &#123; exit; &#125; $date = date(\"Y_m_d\", time()); $fileName .= \"_&#123;$date&#125;.xls\"; //创建PHPExcel对象，注意，不能少了\\ $objPHPExcel = new \\PHPExcel(); $objProps = $objPHPExcel-&gt;getProperties(); //设置表头 $key = ord(\"A\"); foreach ($headArr as $v) &#123; $colum = chr($key); $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($colum . '1', $v); $key += 1; &#125; $column = 2; $objActSheet = $objPHPExcel-&gt;getActiveSheet(); foreach ($data as $key =&gt; $rows) &#123; //行写入 $span = ord(\"A\"); foreach ($rows as $keyName =&gt; $value) &#123;// 列写入 $j = chr($span); $objActSheet-&gt;setCellValue($j . $column, $value); $span++; &#125; $column++; &#125; $fileName = iconv(\"utf-8\", \"gb2312\", $fileName); //重命名表 // $objPHPExcel-&gt;getActiveSheet()-&gt;setTitle('test'); //设置活动单指数到第一个表,所以Excel打开这是第一个表 $objPHPExcel-&gt;setActiveSheetIndex(0); header('Content-Type: application/vnd.ms-excel'); header(\"Content-Disposition: attachment;filename=\\\"$fileName\\\"\"); header('Cache-Control: max-age=0'); $objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5'); $objWriter-&gt;save('php://output'); //文件通过浏览器下载 exit;&#125; 然后调用刚刚封装的方法1234567891011121314public function out()&#123; //要导出的数据放在一个数组里 $data=array( array('username'=&gt;'zhangsan','password'=&gt;\"123456\"), array('username'=&gt;'lisi','password'=&gt;\"abcdefg\"), array('username'=&gt;'wangwu','password'=&gt;\"111111\"), ); //导出的文件名 $filename=\"test_excel\"; //每一列的标题 $headArr=array(\"用户名\",\"密码\"); $this-&gt;getExcel($filename,$headArr,$data);&#125; 后面我们直接调用控制器里的 out方法就可以了！","tags":[]},{"title":"'常用的设计模式之单例模式'","date":"2016-12-29T02:54:39.000Z","path":"2016/12/29/常用的设计模式之单例模式/","text":"单例模式就是只能让我们实例化一次和创建一个对象的类。像文件类，session类等只需要实例化一次就可以在全局中应用。 1、 非单例模式的普通类，会出现的问题。1234567891011121314151617181920212223&lt;?phpclass Db&#123; private $instance=null; public function __construct($config=[]) &#123; $dsn = sprintf('mysql:host=%s;dbname=%s', $config['db_host'], $config['db_name']); $this-&gt;db = new PDO($dsn, $config['db_user'], $config['db_pass']); &#125;&#125;$config = array( 'db_name' =&gt; 'phpcmsv9', 'db_host' =&gt; 'localhost', 'db_user' =&gt; 'root', 'db_pass' =&gt; 'root');$ob=new Db($config);var_dump($ob);$ob2=new Db($config);var_dump($ob2);$ob3=new Db($config);var_dump($ob3);?&gt; 上面会输出的内容为：(1) &#123;1234567891011121314 [&quot;db&quot;:&quot;Db&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125;object(Db)#3 (1) &#123; [&quot;db&quot;:&quot;Db&quot;:private]=&gt; object(PDO)#4 (0) &#123; &#125;&#125;object(Db)#5 (1) &#123; [&quot;db&quot;:&quot;Db&quot;:private]=&gt; object(PDO)#6 (0) &#123; &#125;&#125; 每个对象都会占用一个资源，如果实例100次就会占用100次，非常消耗服务器内存和资源。 2、 单例模式例子12345678910111213141516171819202122232425262728293031&lt;?phpclass Test&#123; private static $instance=null; private $db=null; private function __construct($config=array()) &#123; $dsn = sprintf('mysql:host=%s;dbname=%s', $config['db_host'], $config['db_name']); $this-&gt;db = new PDO($dsn, $config['db_user'], $config['db_pass']); &#125; public static function getInstance($config=array()) &#123; if(self::$instance == null) &#123; self::$instance= new self($config); &#125; return self::$instance; &#125;&#125;$config = array( 'db_name' =&gt; 'phpcmsv9', 'db_host' =&gt; 'localhost', 'db_user' =&gt; 'root', 'db_pass' =&gt; 'root');$obj=Test::getInstance($config);var_dump($obj);$obj1=Test::getInstance($config);var_dump($obj1);$obj2=Test::getInstance($config);var_dump($obj2);?&gt; 上面的输出内容为：123456789101112131415object(Test)#1 (1) &#123; [&quot;db&quot;:&quot;Test&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125;object(Test)#1 (1) &#123; [&quot;db&quot;:&quot;Test&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125;object(Test)#1 (1) &#123; [&quot;db&quot;:&quot;Test&quot;:private]=&gt; object(PDO)#2 (0) &#123; &#125;&#125; 我们可以看出用单例模式，每次调用都是返回的同一个对象，获得的对象ID是一样的。我们控制住基类，在源头上限制这个类，使它无法生成多个对象，直接返回。 3、总结 单例模式了违法单一职责原则，因为它自己控制了自己的实例化和生命周期。 单例模式对应用表现为全局状态。全局状态被视为是不良设计，因为所有代码都可以修改它的值。在调试的时候，很难弄清楚全局变量的当前状态是哪一段代码造成的。 在单元测试的时候，单例模式难以测试。如果不进行单元测试，又会影响系统的质量。 单例模式在应用请求的整个生命周期中都有效，这点类似全局变量，会降低程序的可测试性。大部分情况下，也可以用依赖注入来代替单例模式，避免在应用中引入不必要的耦合。 所以，对于仅需生成一个对象的类，首先考虑用依赖注入方式，其次考虑用单例模式来实现。","tags":[]},{"title":"hexo 和github搭建个人博客","date":"2016-12-26T08:27:37.673Z","path":"2016/12/26/hexo 和github搭建个人博客/","text":"一、需要安装的软件1、安装git ubuntu上安装git ： sudo apt-get install git windows直接下载git安装包2、安装nodejs ubuntu 上安装node apt install nodejsapt all npm Windows到nodejs官网下载最新版安装包。 二、正式安装hexo 进入你的文件目录 执行以下命令 sudo npm install -g hexo 软件安装完成后初始化它 hexo init 执行成功后就本地就安装完成了，当前目录就是博客的根目录。 生成静态页面 hexo generate 或者 hexo g 本地启动预览 hexo server 或者 hexo s 后面可以加上 --debug 参数查看运行状态，浏览器输入http://localhost:4000 查看本地预览，如果网站打开了说明配置OK。三、配置github 进入你的github，新建一个仓库名字为：名字+github.io 打开你的博客根目录下的 vim _config.yml文件的最后几行，修改 ` 然后执行命令 hexo g hexo d,第一条是重新生成静态页面，第二天是部署到github，执行成功后静态页面就提交到你的github仓库里了。 最后访问你的github地址 xxx.github.io就可以看到效果了。四、绑定域名到github 到你的域名解析后台解析或者修改一个新的域名地址，记录类型为CNAME，记录值为你的github仓库地址：xxx.github.io 如下图所示： 然后在你的博客目录 -&gt;source目录下面新建一个CNAME的文件，内容为你刚刚解析的域名地址。（所以需要提交到github的文件都是放在source这个目录里面的） 再次执行 hexo g和 hexo d就可以了五、hexo常用命令 hexo new &#39;filename 创建新文章 hexo clean 清除缓存 hexo new page &#39;filename&#39; 创建新页面 hexo g 生成页面 hexo d部署项目( 生成并部署可以用hexo d -g ) hexo s 开启预览访问后记 如果你想建设一个写文章的bolg的话，用hexo和github真的是一个不错的选择，没有自己搭建服务器的烦恼。可以把维护网站的时间用来多思考，总结，和分享。又比在其他第三方平台上多了一些个性化的功能。反正我觉得挺棒的。","tags":[]}]